From 5e0d0a178f97854dd25f9bd627ade588d8771fa4 Mon Sep 17 00:00:00 2001
From: Fahad Arslan <Fahad_Arslan@mentor.com>
Date: Fri, 17 Mar 2017 18:06:22 +0500
Subject: [PATCH 1/1] place trace points to R5 remoteproc platform driver

Signed-off-by: Fahad Arslan <Fahad_Arslan@mentor.com>
---
 drivers/remoteproc/zynqmp_r5_remoteproc.c | 47 ++++++++++++++++++++++++++++++-
 1 file changed, 46 insertions(+), 1 deletion(-)

diff --git a/drivers/remoteproc/zynqmp_r5_remoteproc.c b/drivers/remoteproc/zynqmp_r5_remoteproc.c
index 16cb821..0605d76 100644
--- a/drivers/remoteproc/zynqmp_r5_remoteproc.c
+++ b/drivers/remoteproc/zynqmp_r5_remoteproc.c
@@ -21,6 +21,9 @@
  * GNU General Public License for more details.
  */
 
+#include <trace/events/MEMF.h>
+#include <trace/events/Synchronization.h>
+
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/err.h>
@@ -36,6 +39,12 @@
 
 #include "remoteproc_internal.h"
 
+#define	       RPROC_SUCCESS            0
+#define	       RPROC_FAILURE            1
+#define	       REMOTEPROC_BOOT          0
+#define	       REMOTEPROC_SHUTDOWN      1
+#define	       REMOTEPROC_ACTIVE        2
+
 /* define size of scratchpad aread for vring ipi info */
 #define SCRATCHPAD_SIZE	(4 * 1024)
 /* define address of TCM in master address space */
@@ -315,10 +324,17 @@ static void ipi_init(struct zynqmp_r5_rproc_pdata *pdata)
 static void handle_event(struct zynqmp_r5_rproc_pdata *local)
 {
 	struct ipi_info *ipi = (struct ipi_info *) local->scratchpad_base;
+	static bool initialized = false;
 
 	if (rproc_vq_interrupt(local->rproc, 0) == IRQ_NONE)
 		dev_dbg(&remoteprocdev[local->rpu_id]->dev, \
 			"no message found in vqid 0\n");
+	else {
+		if (!initialized) {
+			initialized = true;
+			trace_MEMF_Remoteproc_State(local->rproc, REMOTEPROC_ACTIVE, RPROC_SUCCESS);
+		}
+	}
 
 	iowrite32(-1, &ipi->reg_read);
 
@@ -371,6 +387,7 @@ static int zynqmp_r5_rproc_start(struct rproc *rproc)
 	ret = get_firmware_entry_addr(local, &bootaddr);
 	if (ret < 0) {
 		dev_err(dev, "%s: failed to get RPU boot addr.\n", __func__);
+		trace_MEMF_Remoteproc_State(rproc, REMOTEPROC_BOOT, RPROC_FAILURE);
 		return ret;
 	}
 #if 0
@@ -402,6 +419,7 @@ static int zynqmp_r5_rproc_start(struct rproc *rproc)
 	r5_halt(local, false);
 
 	ipi_init(local);
+	trace_MEMF_Remoteproc_State(rproc, REMOTEPROC_BOOT, RPROC_SUCCESS);
 	return 0;
 }
 
@@ -412,6 +430,7 @@ static void zynqmp_r5_rproc_kick(struct rproc *rproc, int vqid)
 	struct platform_device *pdev = to_platform_device(dev);
 	struct zynqmp_r5_rproc_pdata *local = platform_get_drvdata(pdev);
 	struct ipi_info *ipi = (struct ipi_info *) local->scratchpad_base;
+	static bool initialized = false;
 
 	dev_dbg(dev, "KICK Firmware to start send messages vqid %d\n", vqid);
 
@@ -431,6 +450,11 @@ static void zynqmp_r5_rproc_kick(struct rproc *rproc, int vqid)
 	 * Currently vqid is not used because we only got one.
 	 */
 	reg_write(local->ipi_base, TRIG_OFFSET, local->ipi_dest_mask);
+
+	if (!initialized) {
+		initialized = true;
+		trace_Synchronization_TriggerSend(100, 0, "Trigger");
+	}
 }
 
 /* power off the remote processor */
@@ -447,6 +471,9 @@ static int zynqmp_r5_rproc_stop(struct rproc *rproc)
 
 	reg_write(local->ipi_base, IDR_OFFSET, local->ipi_dest_mask);
 	reg_write(local->ipi_base, ISR_OFFSET, local->ipi_dest_mask);
+
+	trace_MEMF_Remoteproc_State(rproc, REMOTEPROC_SHUTDOWN, RPROC_SUCCESS);
+
 	return 0;
 }
 
@@ -505,8 +532,10 @@ static int zynqmp_r5_remoteproc_probe(struct platform_device *pdev)
 
 	local = devm_kzalloc(&pdev->dev, sizeof(struct zynqmp_r5_rproc_pdata),
 				 GFP_KERNEL);
-	if (!local)
+	if (!local) {
+		trace_MEMF_Remoteproc_Init(NULL, NULL, NULL, RPROC_FAILURE);
 		return -ENOMEM;
+	}
 
 	platform_set_drvdata(pdev, local);
 
@@ -514,6 +543,7 @@ static int zynqmp_r5_remoteproc_probe(struct platform_device *pdev)
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "remote_mem");
 	if (!res) {
 		dev_err(&pdev->dev, "invalid address\n");
+		trace_MEMF_Remoteproc_Init(NULL, NULL, NULL, RPROC_FAILURE);
 		return -ENODEV;
 	}
 
@@ -529,6 +559,7 @@ static int zynqmp_r5_remoteproc_probe(struct platform_device *pdev)
 		DMA_MEMORY_MAP);
 	if (!ret) {
 		dev_err(&pdev->dev, "dma_declare_coherent_memory failed\n");
+		trace_MEMF_Remoteproc_Init(NULL, NULL, NULL, RPROC_FAILURE);
 		ret = -ENOMEM;
 		goto dma_fault;
 	}
@@ -537,6 +568,7 @@ static int zynqmp_r5_remoteproc_probe(struct platform_device *pdev)
 	ret = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(32));
 	if (ret) {
 		dev_err(&pdev->dev, "dma_set_coherent_mask: %d\n", ret);
+		trace_MEMF_Remoteproc_Init(NULL, NULL, NULL, RPROC_FAILURE);
 		goto dma_mask_fault;
 	}
 
@@ -548,6 +580,7 @@ static int zynqmp_r5_remoteproc_probe(struct platform_device *pdev)
 
 	if (IS_ERR(local->scratchpad_base)) {
 		dev_err(&pdev->dev, "Unable to map scratchpad I/O memory\n");
+		trace_MEMF_Remoteproc_Init(NULL, NULL, NULL, RPROC_FAILURE);
 		ret = PTR_ERR(local->scratchpad_base);
 		goto dma_mask_fault;
 	}
@@ -577,6 +610,7 @@ static int zynqmp_r5_remoteproc_probe(struct platform_device *pdev)
 		dev_err(&pdev->dev, "Invalid core_conf mode provided - %s , %d\n",
 			prop, local->rpu_mode);
 		ret = -EINVAL;
+		trace_MEMF_Remoteproc_Init(NULL, NULL, NULL, RPROC_FAILURE);
 		goto dma_mask_fault;
 	}
 
@@ -593,6 +627,7 @@ static int zynqmp_r5_remoteproc_probe(struct platform_device *pdev)
 	local->rpu_base = devm_ioremap(&pdev->dev, res->start, resource_size(res));
 	if (IS_ERR(local->rpu_base)) {
 		dev_err(&pdev->dev, "Unable to map RPU I/O memory\n");
+		trace_MEMF_Remoteproc_Init(NULL, NULL, local->rpu_id, RPROC_FAILURE);
 		ret = PTR_ERR(local->rpu_base);
 		goto dma_mask_fault;
 	}
@@ -602,6 +637,7 @@ static int zynqmp_r5_remoteproc_probe(struct platform_device *pdev)
 	local->crl_apb_base = devm_ioremap(&pdev->dev, res->start, resource_size(res));
 	if (IS_ERR(local->crl_apb_base)) {
 		dev_err(&pdev->dev, "Unable to map CRL_APB I/O memory\n");
+		trace_MEMF_Remoteproc_Init(NULL, NULL, local->rpu_id, RPROC_FAILURE);
 		ret = PTR_ERR(local->crl_apb_base);
 		goto dma_mask_fault;
 	}
@@ -610,6 +646,7 @@ static int zynqmp_r5_remoteproc_probe(struct platform_device *pdev)
 	local->ipi_base = devm_ioremap(&pdev->dev, res->start, resource_size(res));
 	if (IS_ERR(local->ipi_base)) {
 		pr_err("%s: Unable to map IPI\n", __func__);
+		trace_MEMF_Remoteproc_Init(NULL, NULL, local->rpu_id, RPROC_FAILURE);
 		ret = PTR_ERR(local->ipi_base);
 		goto dma_mask_fault;
 	}
@@ -619,6 +656,7 @@ static int zynqmp_r5_remoteproc_probe(struct platform_device *pdev)
 	local->tcm_base = devm_ioremap_nocache(&pdev->dev, TCM_BASE, TCM_SIZE);
 	if (IS_ERR(local->tcm_base)) {
 		dev_err(&pdev->dev, "Unable to map TCM memory\n");
+		trace_MEMF_Remoteproc_Init(NULL, NULL, local->rpu_id, RPROC_FAILURE);
 		ret = PTR_ERR(local->tcm_base);
 		goto dma_mask_fault;
 	}
@@ -628,6 +666,7 @@ static int zynqmp_r5_remoteproc_probe(struct platform_device *pdev)
 	if (local->vring0 < 0) {
 		ret = local->vring0;
 		dev_err(&pdev->dev, "unable to find IPI IRQ\n");
+		trace_MEMF_Remoteproc_Init(NULL, NULL, local->rpu_id, RPROC_FAILURE);
 		goto dma_mask_fault;
 	}
 	ret = devm_request_irq(&pdev->dev, local->vring0,
@@ -636,6 +675,7 @@ static int zynqmp_r5_remoteproc_probe(struct platform_device *pdev)
 	if (ret) {
 		dev_err(&pdev->dev, "IRQ %d already allocated\n",
 			local->vring0);
+		trace_MEMF_Remoteproc_Init(NULL, NULL, local->rpu_id, RPROC_FAILURE);
 		goto dma_mask_fault;
 	}
 	dev_dbg(&pdev->dev, "vring0 irq: %d\n", local->vring0);
@@ -652,6 +692,7 @@ static int zynqmp_r5_remoteproc_probe(struct platform_device *pdev)
 	local->rproc = rproc_alloc(&pdev->dev, dev_name(&pdev->dev),
 		&zynqmp_r5_rproc_ops, rproc_firmware, sizeof(struct rproc));
 	if (!local->rproc) {
+		trace_MEMF_Remoteproc_Init(NULL, rproc_firmware, local->rpu_id, RPROC_FAILURE);
 		dev_err(&pdev->dev, "rproc allocation failed\n");
 		goto rproc_fault;
 	}
@@ -660,9 +701,11 @@ static int zynqmp_r5_remoteproc_probe(struct platform_device *pdev)
 	ret = rproc_add(local->rproc);
 	if (ret) {
 		dev_err(&pdev->dev, "rproc registration failed\n");
+		trace_MEMF_Remoteproc_Init(local->rproc, rproc_firmware, local->rpu_id, RPROC_FAILURE);
 		goto rproc_fault;
 	}
 
+	trace_MEMF_Remoteproc_Init(local->rproc, rproc_firmware, local->rpu_id, RPROC_SUCCESS);
 	return ret;
 
 rproc_fault:
@@ -681,6 +724,8 @@ static int zynqmp_r5_remoteproc_remove(struct platform_device *pdev)
 
 	dev_info(&pdev->dev, "%s\n", __func__);
 
+	trace_MEMF_Remoteproc_DeInit(local->rproc, RPROC_SUCCESS);
+
 	rproc_del(local->rproc);
 	rproc_put(local->rproc);
 
-- 
2.8.1

